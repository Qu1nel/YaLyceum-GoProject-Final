# Chapter 3: Агент

После того, как мы разобрались с [JWT Аутентификацией](02_jwt_аутентификация.md), пришло время узнать о компоненте, который использует эту аутентификацию для обработки запросов пользователей - **Агенте**.

Представьте себе ресторан. Пользователи - это посетители, а **Агент** - это как хостес у входа. Хостес встречает посетителей, проверяет их бронь (аутентификация), узнает, чего они хотят (запрос), и направляет их к свободному столику (Оркестратор). **Агент** делает то же самое, но для нашего приложения.

Центральный пример: Пользователь хочет вычислить выражение `(2+2)*4`. Он отправляет это выражение через интерфейс (Frontend) к **Агенту**. **Агент** проверяет, что пользователь авторизован, а затем передает задачу на вычисление в Оркестратор. Без Агента, пользователю пришлось бы напрямую взаимодействовать с Оркестратором, что было бы небезопасно и сложно.

## Ключевые концепции Агента

Агент состоит из нескольких ключевых концепций:

1.  **Прием запросов:** Агент принимает HTTP запросы от пользователей. Это как хостес, который приветствует посетителей.
2.  **Аутентификация и Авторизация:** Агент проверяет личность пользователя (аутентификация) и его права доступа (авторизация). Это как проверка брони у хостес. Мы используем JWT токены, как мы обсудили в [JWT Аутентификации](02_jwt_аутентификация.md).
3.  **Передача запросов Оркестратору:** Агент передает запросы на вычисление Оркестратору. Это как направление посетителей к свободному столику.
4.  **Взаимодействие с базой данных:** Агент общается с базой данных для управления пользователями и другими данными.

## Как использовать Агента?

Давайте рассмотрим, как пользователь может запросить вычисление выражения через Агента.

**Задача:** Пользователь с ID `a1b2c3d4-e5f6-7890-1234-567890abcdef` хочет вычислить выражение `(2+2)*4`.

1.  **Отправка запроса:** Пользователь отправляет HTTP POST запрос на адрес `/api/v1/calculate` с выражением в формате JSON и JWT токеном в заголовке `Authorization`.

    ```
    POST /api/v1/calculate HTTP/1.1
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
    Content-Type: application/json

    {
      "expression": "(2+2)*4"
    }
    ```

2.  **Обработка запроса Агентом:** Агент получает запрос, проверяет JWT токен, извлекает ID пользователя и передает выражение в Оркестратор.

3.  **Ответ Агента:** Агент возвращает HTTP статус `202 Accepted` и ID задачи (task_id), который Оркестратор присвоил этой задаче.

    ```json
    {
      "task_id": "123e4567-e89b-12d3-a456-426614174000"
    }
    ```

Теперь пользователь может использовать этот `task_id` для отслеживания прогресса вычисления, запросив детали задачи.

## Что происходит под капотом?

Давайте посмотрим, что происходит внутри Агента, когда он получает запрос на вычисление.

1.  **Получение запроса:** Агент получает HTTP запрос на эндпоинт `/api/v1/calculate`.
2.  **Проверка JWT токена:** Middleware `JWTAuth` проверяет JWT токен в заголовке `Authorization`. Если токен невалидный, возвращается ошибка `401 Unauthorized`.
3.  **Извлечение ID пользователя:** Если токен валидный, `JWTAuth` извлекает ID пользователя из токена и добавляет его в контекст запроса.
4.  **Передача запроса в обработчик:** Обработчик `/api/v1/calculate` (функция `Calculate` в `internal/agent/handler/task.go`) получает контекст с ID пользователя и выражение.
5.  **Отправка запроса в Оркестратор:** Обработчик создает gRPC запрос к Оркестратору, передавая ID пользователя и выражение.
6.  **Получение ответа от Оркестратора:** Оркестратор возвращает ID задачи.
7.  **Отправка ответа пользователю:** Обработчик возвращает пользователю HTTP статус `202 Accepted` и ID задачи в формате JSON.

Вот как это выглядит на диаграмме последовательности:

```mermaid
sequenceDiagram
    participant Пользователь
    participant Агент
    participant JWTAuth
    participant Обработчик
    participant Оркестратор

    Пользователь->Агент: POST /api/v1/calculate (expression, JWT token)
    Агент->JWTAuth: Проверка JWT токена
    alt Валидный JWT токен
        JWTAuth-->Агент: userID в контексте
        Агент->Обработчик: Calculate(context, expression)
        Обработчик->Оркестратор: gRPC SubmitExpression(userID, expression)
        Оркестратор-->Обработчик: taskID
        Обработчик-->Агент: taskID
        Агент-->Пользователь: 202 Accepted (task_id)
    else Невалидный JWT токен
        JWTAuth-->Агент: Ошибка
        Агент-->Пользователь: 401 Unauthorized
    end
```

Теперь давайте посмотрим на код, чтобы увидеть, как это реализовано.

```go
// internal/agent/handler/task.go
func (h *TaskHandler) Calculate(c echo.Context) error {
	userID, ok := middleware.GetUserIDFromContext(c) // Получаем userID из контекста
	if !ok {
		// Обработка ошибки, если userID не найден
	}

	var req CalculateRequest
	if err := c.Bind(&req); err != nil {
		// Обработка ошибки, если не удалось привязать тело запроса
	}

	taskID, err := h.taskService.SubmitNewTask(c.Request().Context(), userID, req.Expression) // Отправляем запрос в TaskService
	if err != nil {
		// Обработка ошибки, если TaskService вернул ошибку
	}

	return c.JSON(http.StatusAccepted, CalculateResponse{TaskID: taskID}) // Возвращаем taskID
}
```

В этом коде мы видим, как обработчик `Calculate` получает ID пользователя из контекста (который был добавлен middleware `JWTAuth`), привязывает тело запроса к структуре `CalculateRequest`, вызывает `taskService.SubmitNewTask` для отправки запроса в Оркестратор и возвращает ID задачи пользователю.

```go
// internal/agent/middleware/auth.go
func JWTAuth(jwtManager *jwtauth.Manager) echo.MiddlewareFunc {
	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			authHeader := c.Request().Header.Get("Authorization")
			if authHeader == "" {
				return echo.NewHTTPError(http.StatusUnauthorized, "Требуется авторизация")
			}

			tokenString := strings.Replace(authHeader, "Bearer ", "", 1)

			userID, err := jwtManager.Verify(tokenString) // Проверяем JWT токен
			if err != nil {
				return echo.NewHTTPError(http.StatusUnauthorized, "Невалидный токен")
			}

			ctx := context.WithValue(c.Request().Context(), middleware.UserIDContextKey, userID) // Добавляем userID в контекст
			c.SetRequest(c.Request().WithContext(ctx))
			return next(c)
		}
	}
}
```

Этот код показывает, как `JWTAuth` middleware проверяет JWT токен и добавляет ID пользователя в контекст запроса.

## Заключение

В этой главе мы узнали, что такое **Агент** и как он работает. Мы рассмотрели, как Агент принимает запросы от пользователей, проверяет их личность и передает запросы в Оркестратор. Теперь вы знаете, как Агент служит связующим звеном между пользователем и внутренними сервисами.

В следующей главе мы поговорим о [gRPC Интерфейсах](04_grpc_интерфейсы.md), которые используются для взаимодействия между Агентом и Оркестратором.