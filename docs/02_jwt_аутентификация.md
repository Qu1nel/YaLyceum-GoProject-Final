# Chapter 2: JWT Аутентификация

После [Конфигурации (Config)](01_конфигурация__config_.md), где мы научились настраивать наше приложение, пришло время поговорить о том, как защитить его от несанкционированного доступа. Для этого мы используем **JWT Аутентификацию**.

Представьте, что у вас есть клуб, и только членам клуба разрешено входить. **JWT Аутентификация** - это как система членских билетов. Когда кто-то пытается войти в клуб (обратиться к нашему API), он должен показать свой билет (JWT токен), чтобы доказать, что он является членом клуба (авторизованным пользователем). Если билет валидный, его пускают. Если нет - нет.

## Зачем нам JWT Аутентификация?

Без **JWT Аутентификации**, любой желающий мог бы делать запросы к нашему API, даже если у него нет прав доступа.  Это было бы очень небезопасно!  **JWT Аутентификация** гарантирует, что только те, кто имеет действительный токен, могут получить доступ к нашим ресурсам.

Центральный пример: Представьте, что у нас есть API для управления задачами пользователя. Мы хотим, чтобы только авторизованный пользователь мог просматривать и редактировать свои задачи, а не чужие.  **JWT Аутентификация** позволяет нам это сделать. При входе пользователя, мы выдаем ему JWT токен.  Каждый раз, когда он делает запрос к API (например, для просмотра своих задач), он отправляет этот токен вместе с запросом.  Наш сервер проверяет токен и, если он валидный, разрешает доступ к задачам пользователя.

## Ключевые концепции JWT Аутентификации

JWT Аутентификация состоит из нескольких ключевых концепций:

1.  **JWT (JSON Web Token):** Это как электронный билет. Это строка, содержащая информацию о пользователе, его правах доступа и сроке действия билета. JWT подписывается секретным ключом, чтобы его нельзя было подделать.

2.  **Аутентификация:**  Процесс проверки личности пользователя (например, проверка логина и пароля).  После успешной аутентификации, пользователю выдается JWT токен.

3.  **Авторизация:**  Процесс проверки, имеет ли пользователь право доступа к определенному ресурсу.  Когда пользователь делает запрос к API, сервер проверяет его JWT токен и определяет, разрешен ли ему доступ к этому ресурсу.

4.  **Секретный ключ:**  Это как пароль от нашего клуба.  Он используется для подписи JWT токена, чтобы его нельзя было подделать.  Секретный ключ должен быть известен только серверу.

## Как использовать JWT Аутентификацию?

Давайте рассмотрим пример использования JWT Аутентификации на примере нашего проекта.

**Задача:** Мы хотим защитить API, который позволяет пользователю просматривать свои задачи.

1.  **Регистрация и вход пользователя:**  Сначала пользователь должен зарегистрироваться и войти в систему.  После успешного входа, сервер выдает ему JWT токен.

    ```go
    // Пример (упрощенный) ответа после успешного входа пользователя:
    {
        "userID": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhMWIyYzNkNC1lNWY2LTc4OTAtMTIzNC01Njc4OTBhYmNkZWYiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
    }
    ```

    Здесь `userID` - это идентификатор пользователя, а `token` - это JWT токен, который он будет использовать для доступа к защищенным API.

2.  **Отправка JWT токена в запросе:**  Когда пользователь делает запрос к API для просмотра своих задач, он должен отправить JWT токен в заголовке `Authorization`.

    ```
    GET /api/tasks HTTP/1.1
    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhMWIyYzNkNC1lNWY2LTc4OTAtMTIzNC01Njc4OTBhYmNkZWYiLCJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ```

    Здесь `Bearer` - это схема аутентификации, а после него идет JWT токен.

3.  **Проверка JWT токена на сервере:**  Сервер получает запрос с JWT токеном, проверяет его валидность и, если он валидный, разрешает доступ к задачам пользователя.

    ```go
    // Пример (упрощенный) логики проверки токена:
    userID, err := jwtManager.Verify(tokenString)
    if err != nil {
        // Токен невалидный
        // Возвращаем ошибку 401 Unauthorized
    }

    // Токен валидный, userID извлечен
    // Разрешаем доступ к задачам пользователя с userID
    ```

    Если токен невалидный, сервер возвращает ошибку `401 Unauthorized`.

## Что происходит под капотом?

Давайте разберемся, что происходит, когда мы используем JWT Аутентификацию.

1.  **Аутентификация пользователя:** Пользователь вводит свои логин и пароль. Сервер проверяет их.

2.  **Генерация JWT токена:**  Если логин и пароль верны, сервер генерирует JWT токен.  Этот токен содержит информацию о пользователе (например, его ID) и подписывается секретным ключом.

3.  **Отправка JWT токена пользователю:**  Сервер отправляет JWT токен пользователю.

4.  **Отправка JWT токена с каждым запросом:** Пользователь сохраняет JWT токен и отправляет его с каждым запросом к API в заголовке `Authorization`.

5.  **Проверка JWT токена на сервере:**  Сервер получает запрос с JWT токеном, проверяет его подпись (с помощью секретного ключа) и извлекает информацию о пользователе.

6.  **Авторизация пользователя:** Сервер использует информацию о пользователе из JWT токена для проверки, имеет ли он право доступа к запрошенному ресурсу.

Вот как это выглядит на диаграмме последовательности:

```mermaid
sequenceDiagram
    participant Пользователь
    participant Агент
    participant JWTManager

    Пользователь->Агент: Вход (логин, пароль)
    Агент->Агент: Проверка логина и пароля
    alt Успешная аутентификация
        Агент->JWTManager: Generate(userID)
        JWTManager->JWTManager: Создание JWT токена
        JWTManager-->Агент: JWT токен
        Агент-->Пользователь: JWT токен
    else Неверные учетные данные
        Агент-->Пользователь: Ошибка
    end

    Пользователь->Агент: Запрос к API (с JWT токеном)
    Агент->JWTManager: Verify(JWT токен)
    JWTManager->JWTManager: Проверка JWT токена
    alt Валидный JWT токен
        JWTManager-->Агент: userID
        Агент->Агент: Авторизация пользователя
        Агент->Агент: Обработка запроса
        Агент-->Пользователь: Ответ
    else Невалидный JWT токен
        JWTManager-->Агент: Ошибка
        Агент-->Пользователь: 401 Unauthorized
    end
```

Теперь посмотрим на код `internal/pkg/jwtauth/jwtauth.go` ближе:

```go
package jwtauth

import (
	"time"

	"github.com/golang-jwt/jwt/v5"
)

type Manager struct {
	secretKey []byte
	tokenTTL  time.Duration
}
```

Здесь мы определяем структуру `Manager`, которая отвечает за генерацию и проверку JWT токенов. `secretKey` - это секретный ключ, а `tokenTTL` - это время жизни токена.

```go
func (m *Manager) Generate(userID string) (string, error) {
	expirationTime := time.Now().Add(m.tokenTTL)

	claims := &Claims{ // Claims - это данные, которые мы хотим хранить в токене
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime), // Когда токен истекает
		},
		UserID: userID, // ID пользователя
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) // Создаем новый токен

	tokenString, err := token.SignedString(m.secretKey) // Подписываем токен секретным ключом
	if err != nil {
		return "", err
	}

	return tokenString, nil
}
```

Этот код генерирует JWT токен. Сначала мы создаем `Claims`, которые содержат информацию о пользователе и сроке действия токена. Затем мы создаем новый токен, подписываем его секретным ключом и возвращаем его в виде строки.  `jwt.SigningMethodHS256` указывает на алгоритм подписи HMAC с SHA256.

```go
func (m *Manager) Verify(tokenString string) (userID string, err error) {
	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return m.secretKey, nil
	})

	if err != nil {
		return "", err
	}

	claims, ok := token.Claims.(*Claims)
	if !ok || !token.Valid {
		return "", err
	}

	return claims.UserID, nil
}
```

Этот код проверяет JWT токен.  Мы используем `jwt.ParseWithClaims` для разбора токена и проверки его подписи. Если токен валидный, мы извлекаем `userID` из `Claims` и возвращаем его.

Также, обратите внимание на `internal/agent/middleware/auth.go`. Этот файл содержит `JWTAuth` middleware, который проверяет JWT токен в каждом запросе к API. Он использует `jwtManager.Verify` для проверки токена и извлечения `userID`. Этот `userID` затем добавляется в контекст запроса, чтобы его можно было использовать в обработчиках API.  Middleware - это как привратник у нашего клуба, который проверяет билеты у всех, кто пытается войти.

## Заключение

В этой главе мы узнали, что такое **JWT Аутентификация** и зачем она нужна. Мы рассмотрели, как генерировать и проверять JWT токены, и как использовать их для защиты наших API. Теперь вы знаете, как защитить свое приложение от несанкционированного доступа.

В следующей главе мы поговорим об [Агенте](03_агент.md), который является связующим звеном между пользователем и нашим приложением.


---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)